
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>UIStackView | 寂静喜欢</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="艳遇哥">
    
    <meta name="description" content="本文转自：iOS 9 新增 UIStackView 官方文档翻译
示例Demo纯代码：Github
示例Demo SB版：Github
Demo效果图：
一、继承关系、遵守协议、隶属框架及可用平台先看下官方文档吧：
`
The UIStackView class provides a streamlined interface for laying out a collection of views in either a column or a row. Stack views let you leverage the power of Auto Layout, creating user interfaces that can dynamically adapt to the device’s orientation, screen size, and any changes in the available space. The stack view manages the layout of all the views in its arrangedSubviews property. These views are arranged along the stack view’s axis, based on their order in the arrangedSubviews array. The exact layout varies depending on the stack view’s axis, distribution, alignment, spacing, and other properties.`
UIStackView 类提供了一个高效的接口用于平铺一行或一列的视图组合。Stack视图使你依靠自动布局的能力，创建用户接口使得可以动态的调整设备朝向、屏幕尺寸及任何可用范围内的变化。Stack视图管理着所有在它的 arrangedSubviews 属性中的视图的布局。这些视图根据它们在 arrangedSubviews 数组中的顺序沿着 Stack 视图的轴向排列。精确的布局变量根据 Stack 视图的 axis, distribution, alignment, spacing, 和其它属性共同决定。">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="寂静喜欢" title="寂静喜欢"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="寂静喜欢">寂静喜欢</a></h1>
				<h2 class="blog-motto">人生就像是一场旅行，不必在乎目的地，重要的是沿途的风景以及看风景的心情！既然选择了远方，便只顾风雨兼程！</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:LanceChen2013.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/15/UIStackView详解/" title="UIStackView" itemprop="url">UIStackView</a>
  </h1>
  <p class="article-author">By
    
      <a href="https://LanceChen2013.github.io" title="艳遇哥">艳遇哥</a>
    </p>
  <p class="article-time">
    <time datetime="2016-04-15T05:16:53.000Z" itemprop="datePublished">2016-04-15</time>
    更新日期:<time datetime="2016-04-15T08:02:31.000Z" itemprop="dateModified">2016-04-15</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、继承关系、遵守协议、隶属框架及可用平台"><span class="toc-number">1.</span> <span class="toc-text">一、继承关系、遵守协议、隶属框架及可用平台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、Stack-视图与自动布局"><span class="toc-number">2.</span> <span class="toc-text">二、Stack 视图与自动布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、定位和调整-Stack-视图尺寸"><span class="toc-number">3.</span> <span class="toc-text">三、定位和调整 Stack 视图尺寸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、通用-Stack-视图布局"><span class="toc-number">4.</span> <span class="toc-text">四、通用 Stack 视图布局</span></a></li></ol>
		</div>
		
		<p>本文转自：<a href="http://www.cocoachina.com/ios/20150617/12151.html" target="_blank" rel="external">iOS 9 新增 UIStackView 官方文档翻译</a></p>
<p>示例Demo纯代码：<a href="https://github.com/Lidalu/UIStackView" target="_blank" rel="external">Github</a></p>
<p>示例Demo SB版：<a href="https://github.com/Lidalu/UIStackViewDemo-SB" target="_blank" rel="external">Github</a></p>
<p>Demo效果图：<br><img src="http://img.blog.csdn.net/20160415141854946" alt="UIStackView"></p>
<h3 id="一、继承关系、遵守协议、隶属框架及可用平台"><a href="#一、继承关系、遵守协议、隶属框架及可用平台" class="headerlink" title="一、继承关系、遵守协议、隶属框架及可用平台"></a>一、继承关系、遵守协议、隶属框架及可用平台</h3><p><img src="http://images0.cnblogs.com/blog2015/490613/201506/130105390356699.png" alt="image"><br>先看下官方文档吧：</p>
<p>`</p>
<pre><code>The UIStackView class provides a streamlined interface for laying out a collection of views in either a column or a row. Stack views let you leverage the power of Auto Layout, creating user interfaces that can dynamically adapt to the device’s orientation, screen size, and any changes in the available space. The stack view manages the layout of all the views in its arrangedSubviews property. These views are arranged along the stack view’s axis, based on their order in the arrangedSubviews array. The exact layout varies depending on the stack view’s axis, distribution, alignment, spacing, and other properties.`
</code></pre><p>UIStackView 类提供了一个高效的接口用于平铺一行或一列的视图组合。Stack视图使你依靠自动布局的能力，创建用户接口使得可以动态的调整设备朝向、屏幕尺寸及任何可用范围内的变化。Stack视图管理着所有在它的 arrangedSubviews 属性中的视图的布局。这些视图根据它们在 arrangedSubviews 数组中的顺序沿着 Stack 视图的轴向排列。精确的布局变量根据 Stack 视图的 axis, distribution, alignment, spacing, 和其它属性共同决定。<br><a id="more"></a><br><img src="http://images0.cnblogs.com/blog2015/490613/201506/130054395519774.png" alt="image"></p>
<p>使用 stack 视图，打开一个你希望编辑的 Storyboard，从对象库中拖拽出一个 Horizontal Stack View 或者一个 Vertical Stack View，并放置到你希望的位置上。下一步，将控件或视图拖拽放置到 stack 中，如果需要你可以继续添加视图或者控件给指定的 stack。Interface Builder 将根据 stack 的内容自动调节尺寸。你也可以通过修改属性面板中 Stack视图的属性调整 stack 内容的外观。</p>
<p>　　注意：你需要负责指定 stack 视图的位置和尺寸（可选的）。然后 stack 视图将管理其内容的布局和尺寸。</p>
<h3 id="二、Stack-视图与自动布局"><a href="#二、Stack-视图与自动布局" class="headerlink" title="二、Stack 视图与自动布局"></a>二、Stack 视图与自动布局</h3><p>Stack 视图使用自动布局来定位和控制其管理的视图的尺寸。stack 视图沿着它的轴向拼凑第一个和最后一个被管理视图，使其边界平齐。对于一个水平 stack 视图，这意味着第一个被管理视图的左边界是与 stack 的左边界平齐的，并且最后一个被管理视图右边界与 stack的右边界平齐。对于垂直 stack，上边界和下边界是各自平齐的。如果你设置了 stack 视图的 layoutMarginsRelativeArrangement 属性为 YES，stack 视图将使用相关的边距与其内容对齐，而不是边界。</p>
<p>　　对于除去 UIStackViewDistributionFillEqually 分布以外的分布方式，stack 视图使用被管理视图的 intrinsicContentSize 属性来计算沿着 stack 轴向的视图尺寸。UIStackViewDistributionFillEqually 分布将调节所有被管理视图的在 stack 轴向上拥有相同尺寸，以填充 stack 视图。如果可能，stack 视图将拉伸所有被管理视图，来匹配其在 stack 轴向上最长的原有尺寸（译注：保证长宽比的情况下根据 stack 轴向长度拉伸视图）。</p>
<p>　　对于除去 UIStackViewAlignmentFill 对齐方式以外的对齐方式，stack 视图使用其管理的视图的 intrinsicContentSize 属性来计算视图垂直于 stack 轴向的尺寸。 UIStackViewAlignmentFill 重新调节了所有其管理的视图，使这些视图填充 stack 视图垂直于其轴向空间。如果可能，stack 视图将拉伸其所有管理的视图来匹配其垂直于 stack 轴向的最大固有尺寸。</p>
<p><img src="http://images0.cnblogs.com/blog2015/490613/201506/130143123632995.png" alt="SB"></p>
<h3 id="三、定位和调整-Stack-视图尺寸"><a href="#三、定位和调整-Stack-视图尺寸" class="headerlink" title="三、定位和调整 Stack 视图尺寸"></a>三、定位和调整 Stack 视图尺寸</h3><p>　　当 Stack 视图允许你布局其内容而不直接使用自动布局，你将仍然需要使用自动布局来定位 stack 视图。通常情况下，这意味着需要拼凑至少两个边界相邻的stack来定义它的位置。没有额外约束的情况下，系统会为 stack 视图计算一个尺寸来适应其内容：</p>
<pre><code>　　 沿着 stack 视图轴向，其适应尺寸等于其管理的视图尺寸与间距的和；
　　 垂直于 stack 视图轴向，其适应尺寸等于其管理的视图中最大的视图的尺寸；
　　· 如果 stack 视图的 layoutMarginsRelativeArrangement 属性设置为 YES，stack 视图的适应尺寸会包括边距空间。
</code></pre><p>　　你可以提供额外的约束来具体说明 stack 视图的高度、宽度或者两者兼有。在这些情况下，stack 视图调整了其管理的视图的布局和尺寸来填充指定区域。精确的布局变量根据 stack 视图的属性获得。可以通过查看 UIStackViewDistribution 和 UIStackViewAlignment 枚举，以获得一个完整的 stack 视图在其内容空间多余或空间不足情况下的处理描述。</p>
<p>　　你也可以根据 stack 视图的第一条或最后一条基线定位它，而不是使用顶部、底部或者中心的Y值。类似于 stack 视图的适应尺寸，这些基线都是基于 stack 视图的内容计算得到的。</p>
<pre><code>　　· 一个水平的 stack 视图调用 viewForFirstBaselineLayout 方法或 viewForLastBaselineLayout 方法时返回它最高的视图。如果最高的视图也是一个 stack 视图，那么其返回的将是在嵌套的 stack 视图上调用 viewForFirstBaselineLayout 方法或 viewForLastBaselineLayout 方法的结果。

　　· 一个垂直的 stack 视图当调用 viewForFirstBaselineLayout 方法时返回的是其管理的第一个视图，当调用 viewForLastBaselineLayout 方法时返回的是其管理的最后一个视图。如果这两个视图之一也是 stack 视图，那么其返回的将是在嵌套的 stack 视图上对应调用 viewForFirstBaselineLayout 方法或 viewForLastBaselineLayout 方法的结果。
</code></pre><p>　　注意：基线对齐方式只作用于那些高度匹配其原本内容高度的视图。如果视图被拉伸或压缩过，那么基线将出现在错误的位置上。</p>
<h3 id="四、通用-Stack-视图布局"><a href="#四、通用-Stack-视图布局" class="headerlink" title="四、通用 Stack 视图布局"></a>四、通用 Stack 视图布局</h3><p>　　这有一些通用方法用于 stack 视图。这个清单是要高亮一些有用的示例来显示 stack 视图的灵活性。目前这还不是一个完整的清单。</p>
<p>　　· 只是定义位置。你可以通过固定两个与其父视图相邻的边界来定义 stack 视图的位置。在这里，stack 视图的尺寸将根据其管理的视图在两个维度上自由扩展。当你想要 stack 视图的内容展现其原有内容尺寸，和你想要管理其他与 stack 视图有关联的用户接口元素时是特别有用的。</p>
<p>　　举个例子，在 Figure 1中，stack 视图的左边界和上边界都已经相对固定于其父视图。这些标签将根据带有8个点的两者之间的空间作为第一基线校准。这对于相对于其本身左对齐的 stack 视图内容是有效的。</p>
<p>　　Figure 1.定义位置<br>　　<img src="http://images0.cnblogs.com/blog2015/490613/201506/140040561762600.png" alt="image"><br>　　<br>　　· 定义沿着 stack 视图轴向的尺寸。这里，你固定了沿着 stack 视图轴向相对于其父视图的两个边界，定义了 stack 视图沿着其轴向的尺寸。你将需要固定其他边界中的一个来定义 stack 视图的位置。stack 视图将沿着其轴向改变尺寸和位置来填充定义的空间；然而，未固定的边界将根据其管理的最大视图的尺寸自由移动。</p>
<p>　　举例如 Figure 2，stack 视图的左、上、右边界都已经相对于其父视图固定了。使用 UIStackViewDistributionFill 分布使得其内容重设尺寸来填充它的宽度，并且从文本框有比标签更低的内容紧凑优先级开始，它将在必要的时候被拉伸。</p>
<p>　　Figure 2.定义沿着 stack 视图轴向的尺寸<br>　　<img src="http://images0.cnblogs.com/blog2015/490613/201506/140059516762099.png" alt="image"><br>　　· 定义垂直于 stack 视图轴向的尺寸。这类似于上一个示例，但是你固定了垂直于 stack 视图轴向的两个边界和沿着轴向的一个边界。这使得 stack 视图在你增加或移除其管理的视图时将沿着其轴向扩展或回缩。除非你使用了 UIStackViewDistributionFillEqually 分布，被管理的视图将根据其原有尺寸调节尺寸。垂直于其轴向的视图将根据其 stack 视图的对其模式在其定义的范围内平铺。</p>
<p>　　举例，Figure 3展示了一个包含了四个标签和一个按钮的垂直 stack 视图。这个 stack 视图使用了8个点的间隙和 UIStackViewAlignmentCenter 对齐方式。stack 视图的高度将根据 stack 内部的元素的增减而增大或回缩。</p>
<p>　　Figure 3.定义垂直于 stack 视图轴向的尺寸<br>　　<img src="http://images0.cnblogs.com/blog2015/490613/201506/140110013482874.png" alt="image"><br>　　Figure 4.同时定义 stack 视图的位置和尺寸<br>　　<img src="http://images0.cnblogs.com/blog2015/490613/201506/140122324105787.png" alt="image">
　　</p>
<p>###五、管理 Stack 视图的展现</p>
<p>　　UIStackView 是 UIView 的非渲染型子类。它没有提供其自有的任何用户接口。相反的，它只管理被其管理的视图的位置和尺寸。因此，有些属性(如 backgroundColor)在 stack 视图上是无效的。类似的，你无法重写 layerClass，drawRect: 或 drawLayer:inContext: 方法。</p>
<p>　　这里有一系列的属性来定义 stack 视图如何平铺其内容。</p>
<p>　　· axis(轴向) 属性决定了 stack 的朝向，只有垂直或水平；<br>　　· distribution(分布) 属性决定了其管理的视图在沿着其轴向上的布局；<br>　　· alignment(对齐) 属性决定了其管理的视图在垂直于其轴向上的布局；<br>　　· spacing(空隙) 属性决定了其管理的视图间的最小间隙；<br>　　· baselineRelativeArrangement 属性决定了其视图间的垂直间隙是否根据基线测量得到；<br>　　· layoutMarginsRelativeArrangement 属性决定了 stack 视图平铺其管理的视图时是否要参照它的布局边距</p>
<p>　　通常情况下，你会使用一个 stack 视图来布局小数量的视图。你可以通过在其他 stack 视图中嵌套多个 stack 视图的方式创建更加复杂的视图层次结构。举例，Figure 5展示了一个包含两个水平 stack 视图的垂直 stack 视图。每一个水平 stack 视图各包含一个标签和一个文本框。</p>
<p>　　Figure 5.Stack 视图的嵌套<br>　　<img src="http://images0.cnblogs.com/blog2015/490613/201506/140146204108925.png" alt="image"><br>　　<br>　　你也可以通过增加被管理的视图的额外约束来完美的调节一个被管理视图的展现。举例说明，你可以使用约束类设置视图的最小或最大的高度或宽度。或者你可以定义一个长宽比。当平铺其内容时，stack 视图将使用这些约束。举例来说，在Figure 4中，当图片被缩放时，图片视图的一个长宽比约束被强行赋予了一个长宽比常数。</p>
<p>　　注意：当给一个 stack 视图内的视图增加约束时要特别注意避免传入冲突。作为惯例，如果一个视图的尺寸在一个指定的维度上默认回到其原本内容尺寸，那么你可以安全的在这个维度上增加约束。</p>
<p>###六、维护其管理的视图与子视图之间的统一性</p>
<p> 　　Stack 视图确保它的 arrangedSubviews 属性将一直是其 subviews 属性的子集合。明确的说，stack 视图强制实施了以下规定：</p>
<p>　　· 无论何时 stack 视图增加了一个视图到它的 arrangedSubviews 数组，其也将把这个视图作为子视图增加，如果还未增加的话。</p>
<p>　　· 无论何时一个子视图从 stack 视图中被移除，那么 stack 视图也将将其从 arrangedSubviews 数组中移除。</p>
<p>　　· 从 arrangedSubviews 移除一个视图并不会将其作为子视图移除。stack 视图将不再管理该视图的尺寸和位置，但是该视图仍将是视图结构的一部分，并且当其可见的情况下仍会被渲染到屏幕上。</p>
<p>　　当 arrangedSubviews 数组一直包含着 subviews 数组的子集合，这些数组间的顺序仍然是独立的。</p>
<p>　　· arrangedSubviews 数组的顺序定义了展现在 stack 中的视图的顺序。对于水平 stack 视图，这些视图将以阅读顺序平铺，即较小索引的视图在较大索引视图的左侧。对于垂直 stack 视图，这些视图是从上到下平铺的，及较小索引的视图在较大索引视图的上方。</p>
<p>　　· subviews 数组中的顺序定义了子视图在Z轴上是顺序。如果视图重叠，有较小索引的子视图将出现在有较大索引的子视图后方。
　　</p>
<p>###七、动态改变 Stack 视图内容</p>
<p>　　当视图被加入、移出或插入 arrangedSubviews 数组时，或当一个被管理的子视图的 hidden 属性改变时，stack 视图都会自动更新它的布局。 </p>
<p>　　OC代码如下：<br>　　`</p>
<pre><code>　// Appears to remove the first arranged view from the stack.
// The view is still inside the stack, it‘s just no longer visible, and no longer contributes to the layout.
UIView * firstView = self.stackView.arrangedSubviews[0];
firstView.hidden = YES;

`
</code></pre><p>　　Swift代码如下：</p>
<pre><code>`// Appears to remove the first arranged view from the stack.
// The view is still inside the stack, it‘s just no longer visible, and no longer contributes to the layout.
let firstView = stackView.arrangedSubviews[0]
firstView.hidden = true`
</code></pre><p>　　stack 视图也会自动响应其任何属性的改变。举例，你可以更新 stack 视图的 axis 属性来动态改变的朝向。</p>
<p>　　OC代码如下：</p>
<pre><code>`// Toggle between a vertical and horizontal stack
if (self.stackView.axis == UILayoutConstraintAxisHorizontal) {
    self.stackView.axis = UILayoutConstraintAxisVertical;
}
else {
    self.stackView.axis = UILayoutConstraintAxisHorizontal;
}    `
</code></pre><p>Swift代码如下：    　　</p>
<pre><code>`// Toggle between a vertical and horizontal stack
if stackView.axis == .Horizontal {
    stackView.axis = .Vertical
}
else {
    stackView.axis = .Horizontal
}`
</code></pre><p>　　对于被管理的子视图的 hidden 属性的变化和 stack 视图属性的变化，你可以通过将这些改变内置到一个动画块代码的方式以动画方式展现。</p>
<p>　　OC代码如下：</p>
<pre><code>`// Animates removing the first item in the stack.
[UIView animateWithDuration:0.25 animations:^{
    UIView * firstView = self.stackView.arrangedSubviews[0];
    firstView.hidden = YES;
}];`
</code></pre><p>　　Swift代码如下：</p>
<pre><code>`
// Animates removing the first item in the stack.
UIView.animateWithDuration(0.25) { () -&gt; Void in
    let firstView = stackView.arrangedSubviews[0]
    firstView.hidden = true
}`

最后，你可以直接在Interface Builder中给很多 stack 视图属性定义特定的 “尺寸类” 类型值。系统将在 stack 视图的尺寸类改变时动画展现这些改变。
</code></pre><p>###八、常用的方法</p>
<p>　　创建 Stack 视图</p>
<pre><code>`    - initWithArrangedSubviews:  (New in iOS 9.0)
</code></pre><p>`　　<br>    管理安排的子视图</p>
<pre><code>`    - addArrangedSubview: (New in iOS 9.0)
      arrangedSubviews Property (New in iOS 9.0)
    - insertArrangedSubview:atIndex: (New in iOS 9.0)
    - removeArrangedSubview: (New in iOS 9.0)`
</code></pre><p>　　设置布局</p>
<pre><code>`    alignment Property  (New in iOS 9.0)
    axis Property  (New in iOS 9.0)
    baselineRelativeArrangement Property  (New in iOS 9.0)
    distribution Property  (New in iOS 9.0)
    layoutMarginsRelativeArrangement Property  (New in iOS 9.0)
    spacing Property  (New in iOS 9.0)`
</code></pre><p>　　常量</p>
<pre><code>`    UIStackViewDistribution
    UIStackViewAlignment`    
</code></pre>  
	</div>
		<footer class="article-footer clearfix">




<div class="article-share" id="share">

  <div data-url="https://LanceChen2013.github.io/2016/04/15/UIStackView详解/" data-title="UIStackView | 寂静喜欢" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2016/04/12/GCD由浅入深学习/"  title="GCD由浅入深学习">
 <strong>NEXT:</strong><br/> 
 <span>GCD由浅入深学习
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、继承关系、遵守协议、隶属框架及可用平台"><span class="toc-number">1.</span> <span class="toc-text">一、继承关系、遵守协议、隶属框架及可用平台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、Stack-视图与自动布局"><span class="toc-number">2.</span> <span class="toc-text">二、Stack 视图与自动布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、定位和调整-Stack-视图尺寸"><span class="toc-number">3.</span> <span class="toc-text">三、定位和调整 Stack 视图尺寸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、通用-Stack-视图布局"><span class="toc-number">4.</span> <span class="toc-text">四、通用 Stack 视图布局</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  

  

  <div class="rsspart">
	<a href="null" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2016 
		
		<a href="https://LanceChen2013.github.io" target="_blank" title="艳遇哥">艳遇哥</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






  </body>
</html>
